<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>医院空间效能规划系统 V4.0 (Space Syntax Integrated)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* --- Theme Variables --- */
        :root {
            /* Dark Mode (Default) */
            --bg-app: #0f172a;
            --bg-gradient-center: #1e293b;
            --bg-gradient-edge: #0f172a;
            --bg-panel: rgba(15, 23, 42, 0.95);
            --bg-panel-solid: #0f172a;
            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --border-color: rgba(255, 255, 255, 0.15);
            --border-faint: rgba(255, 255, 255, 0.05);
            --input-bg: #0f172a;
            --input-border: #334155;
            --btn-ghost-hover: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.4);
            --kpi-bg: rgba(15, 23, 42, 0.85);
            --matrix-bg: #1e293b;
            --matrix-border: #334155;
            --grid-line-1: #334155;
            --grid-line-2: #1e293b;
            --chart-grid: #334155;
            --chart-text: #94a3b8;
            --ai-msg-user: #1e3a8a;
            --ai-msg-bot: #1e293b;
        }

        [data-theme="light"] {
            /* Light Mode */
            --bg-app: #f8fafc;
            --bg-gradient-center: #ffffff;
            --bg-gradient-edge: #e2e8f0;
            --bg-panel: rgba(255, 255, 255, 0.95);
            --bg-panel-solid: #ffffff;
            --text-main: #1e293b;
            --text-muted: #64748b;
            --border-color: rgba(0, 0, 0, 0.15);
            --border-faint: rgba(0, 0, 0, 0.05);
            --input-bg: #ffffff;
            --input-border: #cbd5e1;
            --btn-ghost-hover: rgba(0, 0, 0, 0.05);
            --shadow-color: rgba(0, 0, 0, 0.1);
            --kpi-bg: rgba(255, 255, 255, 0.85);
            --matrix-bg: #f1f5f9;
            --matrix-border: #cbd5e1;
            --grid-line-1: #cbd5e1;
            --grid-line-2: #e2e8f0;
            --chart-grid: #e2e8f0;
            --chart-text: #64748b;
            --ai-msg-user: #dbeafe;
            --ai-msg-bot: #f1f5f9;
        }

        body { margin: 0; overflow: hidden; font-family: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-app); color: var(--text-main); transition: background-color 0.3s, color 0.3s; }
        
        /* Layout & Nav */
        #app-container { width: 100vw; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        #main-nav { height: 56px; background: var(--bg-panel); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 2000; backdrop-filter: blur(10px); transition: background 0.3s; position: relative; flex-shrink: 0; }
        .nav-brand { font-weight: 700; font-size: 18px; color: #0ea5e9; display: flex; align-items: center; gap: 8px; }
        .nav-tabs { display: flex; gap: 4px; background: var(--border-faint); padding: 4px; border-radius: 8px; border: 1px solid var(--border-color); }
        .nav-tab { padding: 6px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; color: var(--text-muted); display: flex; align-items: center; gap: 6px; }
        .nav-tab:hover { color: var(--text-main); background: var(--btn-ghost-hover); }
        .nav-tab.active { background: #0ea5e9; color: white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }

        /* Views */
        .view-section { flex: 1; position: relative; overflow: hidden; display: none; }
        .view-section.active { display: block; }
        #canvas-container { width: 100%; height: 100%; display: block; outline: none; background: radial-gradient(circle at center, var(--bg-gradient-center) 0%, var(--bg-gradient-edge) 100%); }

        /* Generic Panels */
        .panel { background: var(--bg-panel); backdrop-filter: blur(12px); border: 1px solid var(--border-color); border-radius: 12px; pointer-events: auto; box-shadow: 0 8px 32px var(--shadow-color); z-index: 100; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s; }
        
        /* Sidebars */
        .sidebar { position: absolute; top: 16px; bottom: 16px; width: 380px; display: flex; flex-direction: column; overflow: visible; padding: 0; }
        .sidebar.left { left: 16px; } .sidebar.right { right: 16px; }
        .sidebar.collapsed-left { transform: translateX(-396px); } .sidebar.collapsed-right { transform: translateX(396px); }
        .sidebar-header { padding: 16px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; background: var(--border-faint); }
        .sidebar-content { flex: 1; overflow-y: auto; padding: 16px; }
        .sidebar-content::-webkit-scrollbar { width: 4px; }
        .sidebar-content::-webkit-scrollbar-thumb { background: var(--text-muted); border-radius: 4px; }

        /* Toggle Buttons */
        .toggle-btn { position: absolute; top: 50%; transform: translateY(-50%); width: 20px; height: 48px; background: var(--matrix-border); border: 1px solid var(--border-color); color: var(--text-muted); display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; transition: all 0.2s; }
        .toggle-btn:hover { background: #0ea5e9; color: white; }
        .sidebar.left .toggle-btn { right: -20px; border-radius: 0 8px 8px 0; border-left: none; }
        .sidebar.right .toggle-btn { left: -20px; border-radius: 8px 0 0 8px; border-right: none; }

        /* Matrix Tabs */
        .matrix-tabs { display: flex; width: 100%; border-bottom: 1px solid var(--border-color); margin-bottom: 10px; }
        .matrix-tab { flex: 1; text-align: center; padding: 8px; font-size: 11px; font-weight: bold; cursor: pointer; color: var(--text-muted); border-bottom: 2px solid transparent; transition: all 0.2s; }
        .matrix-tab.active { color: #0ea5e9; border-bottom-color: #0ea5e9; background: var(--bg-gradient-center); }
        .matrix-tab:hover { color: var(--text-main); }

        /* Analysis Dashboard */
        #analysis-dashboard { 
            position: absolute; 
            bottom: 80px; 
            left: 50%; 
            transform: translateX(-50%); 
            width: auto;
            max-width: 80%;
            height: auto; 
            pointer-events: none; 
            display: flex; 
            justify-content: center; 
            gap: 12px; 
            z-index: 90; 
            transition: all 0.3s; 
        }
        
        .kpi-card { 
            background: var(--kpi-bg); 
            backdrop-filter: blur(8px); 
            border: 1px solid var(--border-color); 
            border-radius: 10px; 
            padding: 12px 16px; 
            width: 140px; 
            min-height: 90px;
            display: flex; 
            flex-direction: column; 
            justify-content: space-between; 
            pointer-events: auto; 
            box-shadow: 0 4px 12px var(--shadow-color); 
            position: relative; 
            overflow: hidden; 
        }
        
        .kpi-card::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 3px; background: var(--text-muted); }
        .kpi-card.good::before { background: #10b981; } .kpi-card.warn::before { background: #f59e0b; } .kpi-card.bad::before { background: #ef4444; }
        .kpi-title { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
        .kpi-value { font-size: 20px; font-weight: 700; color: var(--text-main); font-family: 'JetBrains Mono', monospace; margin: 4px 0; }
        .kpi-sub { font-size: 9px; color: var(--text-muted); line-height: 1.2; }

        /* Slice Control Panel */
        #slice-panel {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            padding: 8px 20px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            display: flex;
            gap: 16px;
            align-items: center;
            z-index: 95;
            min-width: 400px;
            pointer-events: auto;
            box-shadow: 0 4px 20px var(--shadow-color);
        }
        /* Custom Toggle Switch */
        .slice-toggle-wrapper { position: relative; width: 36px; height: 18px; }
        .slice-checkbox { opacity: 0; width: 0; height: 0; }
        .slice-slider-bg { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--text-muted); transition: .4s; border-radius: 34px; }
        .slice-slider-bg:before { position: absolute; content: ""; height: 14px; width: 14px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        .slice-checkbox:checked + .slice-slider-bg { background-color: #0ea5e9; }
        .slice-checkbox:checked + .slice-slider-bg:before { transform: translateX(18px); }
        
        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #0ea5e9; cursor: pointer; margin-top: -5px; box-shadow: 0 0 0 2px var(--bg-app); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: var(--border-color); border-radius: 2px; }

        /* Matrix Editor - UPDATED STYLES */
        .matrix-container { display: grid; gap: 2px; margin-top: 10px; overflow-x: auto; padding-bottom: 8px; max-height: 60vh; }
        
        .matrix-header { 
            font-size: 10px; 
            color: var(--text-muted); 
            text-align: left; 
            writing-mode: vertical-rl; 
            height: 80px; 
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 4px 0;
            font-weight: 500;
        }
        
        .matrix-row-label { 
            font-size: 10px;
            color: var(--text-main); 
            white-space: nowrap; 
            text-align: right; 
            padding-right: 10px; 
            line-height: 24px;
            font-weight: 500;
        }
        
        .matrix-cell { 
            width: 24px;
            height: 24px;
            background: var(--matrix-bg); 
            border: 1px solid var(--matrix-border); 
            border-radius: 3px; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 10px;
            font-weight: 700;
            color: transparent; 
            transition: all 0.1s; 
        }
        .matrix-cell:hover { transform: scale(1.2); z-index: 10; border-color: var(--text-main); box-shadow: 0 0 8px rgba(0,0,0,0.3); }
        
        .matrix-cell.val-0 { background: var(--matrix-bg); }
        .matrix-cell.val-1 { background: #172554; color: #60a5fa; } 
        .matrix-cell.val-2 { background: #1e3a8a; color: white; } 
        .matrix-cell.val-3 { background: #2563eb; color: white; } 
        .matrix-cell.val-4 { background: #7c3aed; color: white; } 
        .matrix-cell.val-5 { background: #db2777; color: white; box-shadow: 0 0 5px #db2777; }
        
        .matrix-cell-diagonal {
            width: 24px; height: 24px;
            background: rgba(255,255,255,0.03);
            border: 1px dashed var(--border-faint);
            border-radius: 3px;
            display: flex; align-items: center; justify-content: center;
            font-size: 8px; color: var(--border-color);
            cursor: default;
        }
        .matrix-cell-hidden {
            width: 24px; height: 24px;
            background: transparent;
            border: none;
            pointer-events: none;
        }

        /* Diagnostics Panel */
        .diag-item { padding: 8px; border-radius: 6px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.2); margin-bottom: 6px; font-size: 11px; color: #fca5a5; display: flex; gap: 8px; align-items: start; }
        [data-theme="light"] .diag-item { background: rgba(239, 68, 68, 0.05); color: #dc2626; border-color: rgba(239, 68, 68, 0.3); }
        
        .diag-item.warn { background: rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.2); color: #fdba74; }
        [data-theme="light"] .diag-item.warn { background: rgba(245, 158, 11, 0.05); color: #d97706; border-color: rgba(245, 158, 11, 0.3); }
        
        .diag-item.info { color: var(--text-muted); border-color: var(--border-color); background: var(--border-faint); }

        /* UI Elements */
        .btn { padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; border: none; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 6px; }
        .btn-primary { background: #0ea5e9; color: white; } .btn-primary:hover { background: #0284c7; }
        .btn-secondary { background: var(--matrix-border); color: var(--text-main); } .btn-secondary:hover { background: var(--text-muted); color: white; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-ghost { background: transparent; color: var(--text-muted); border: 1px solid var(--border-color); } .btn-ghost:hover { background: var(--btn-ghost-hover); color: var(--text-main); }
        .btn-success { background: #10b981; color: white; } .btn-success:hover { background: #059669; }
        .btn-ai { background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); color: white; border:1px solid rgba(255,255,255,0.2); box-shadow: 0 0 10px rgba(168, 85, 247, 0.4); }
        .btn-ai:hover { box-shadow: 0 0 15px rgba(168, 85, 247, 0.6); transform: translateY(-1px); }
        .btn-orange { background: rgba(249, 115, 22, 0.15); color: #fb923c; border: 1px solid rgba(249, 115, 22, 0.3); } .btn-orange:hover { background: rgba(249, 115, 22, 0.25); }

        .form-group { margin-bottom: 12px; }
        .form-label { font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px; }
        .form-input { width: 100%; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text-main); padding: 6px 8px; border-radius: 4px; font-size: 12px; }
        .form-input:focus { border-color: #0ea5e9; outline: none; }

        /* View Controls */
        #view-controls { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: var(--bg-panel); padding: 6px 16px; border-radius: 99px; display: flex; gap: 8px; border: 1px solid var(--border-color); z-index: 90; align-items: center; box-shadow: 0 4px 12px var(--shadow-color); flex-wrap: wrap; justify-content: center; max-width: 90vw; }
        .v-btn { padding: 4px 8px; border-radius: 12px; cursor: pointer; transition: all 0.2s; font-size: 11px; color: var(--text-muted); font-weight: 600; white-space: nowrap; }
        .v-btn:hover, .v-btn.active { background: var(--matrix-border); color: var(--text-main); }
        .v-btn-icon { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: var(--border-faint); color: var(--text-muted); cursor: pointer;}
        .v-btn-icon:hover, .v-btn-icon.active { background: #0ea5e9; color: white; }

        /* Zoom Controls */
        #zoom-controls { position: absolute; bottom: 90px; right: 24px; display: flex; flex-direction: column; gap: 8px; z-index: 110; }
        .btn-zoom { width: 36px; height: 36px; background: var(--bg-panel); backdrop-filter: blur(8px); border: 1px solid var(--border-color); border-radius: 10px; color: var(--text-muted); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; box-shadow: 0 4px 12px var(--shadow-color); }
        .btn-zoom:hover { background: #0ea5e9; color: white; transform: translateY(-1px); border-color: #0ea5e9; }
        
        /* Labels */
        .dept-label { position: absolute; pointer-events: none; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; text-shadow: 0 2px 4px rgba(0,0,0,0.8); transition: opacity 0.2s; white-space: nowrap; }
        .dept-name { background: rgba(0,0,0,0.6); padding: 2px 6px; border-radius: 4px; font-size: 12px; color: white; font-weight: 600; margin-bottom: 2px; border: 1px solid rgba(255,255,255,0.2); display: flex; gap: 4px; align-items: center; }
        .dept-area { font-size: 10px; color: #94a3b8; background: rgba(255,255,255,0.1); padding: 0 4px; border-radius: 2px; }
        .dept-issue { background: #ef4444; color: white; font-size: 10px; padding: 1px 4px; border-radius: 2px; margin-top: 2px; display: none; }
        .dist-label { position: absolute; background: white; color: black; font-size: 10px; padding: 1px 4px; border-radius: 3px; font-weight: bold; transform: translate(-50%, -50%); font-family: monospace; border: 1px solid rgba(0,0,0,0.2); z-index: 5; }

        /* Physics Modes */
        .btn-mode-0 { color: var(--text-muted); }
        .btn-mode-1 { color: #34d399; background: rgba(16, 185, 129, 0.15); }
        .btn-mode-2 { color: #60a5fa; background: rgba(59, 130, 246, 0.2); }

        /* Legend */
        #legend { 
            position: absolute; 
            bottom: 190px; 
            right: 24px; 
            background: var(--bg-panel); 
            padding: 8px 12px; 
            border-radius: 8px; 
            font-size: 10px; 
            color: var(--text-muted); 
            display: flex; 
            flex-direction: column; 
            gap: 4px; 
            pointer-events: none; 
            border: 1px solid var(--border-color); 
            z-index: 100;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

        /* Selection Box */
        #selection-box { position: absolute; border: 1px solid #0ea5e9; background: rgba(14, 165, 233, 0.2); pointer-events: none; display: none; z-index: 200; }
        
        /* Shortcut Hint */
        #shortcut-hint { 
            position: absolute; 
            top: 70px; 
            left: 50%; 
            transform: translateX(-50%); 
            pointer-events: none; 
            background: var(--bg-panel); 
            padding: 4px 12px; 
            border-radius: 20px; 
            font-size: 11px; 
            color: var(--text-muted); 
            opacity: 0.8; 
            z-index: 80;
            border: 1px solid var(--border-color);
        }
        
        /* AI Chat */
        .msg-bubble { padding: 8px 12px; border-radius: 12px; margin-bottom: 8px; max-width: 85%; font-size: 13px; line-height: 1.5; }
        .msg-user { background: var(--ai-msg-user); color: var(--text-main); align-self: flex-end; border-radius: 12px 12px 0 12px; }
        .msg-bot { background: var(--ai-msg-bot); color: var(--text-main); align-self: flex-start; border-radius: 12px 12px 12px 0; border: 1px solid var(--border-color); }
        .msg-bot ul { list-style-type: disc; margin-left: 20px; margin-top: 4px; }
        .msg-bot strong { color: #60a5fa; }
        .typing-dot { width: 6px; height: 6px; background: var(--text-muted); border-radius: 50%; display: inline-block; animation: typing 1.4s infinite ease-in-out both; }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; } .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

        /* Report Tables */
        .report-cell { padding: 12px 16px; border-bottom: 1px solid var(--border-color); }
        .report-header { background: var(--input-bg); color: var(--text-muted); text-transform: uppercase; font-size: 11px; font-weight: 600; padding: 12px 16px; border-bottom: 2px solid var(--border-color); text-align: left; }
        .status-badge { padding: 2px 8px; border-radius: 99px; font-size: 10px; font-weight: 700; display: inline-block; }
        .status-ok { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .status-warn { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .status-bad { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

        /* Syntax Badge */
        .syntax-badge { font-size:9px; padding:1px 4px; border-radius:3px; background:#475569; color:white; }
        .syntax-val { font-family: monospace; font-weight: bold; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="app-container">
        <nav id="main-nav">
            <div class="nav-brand"><i class="fas fa-hospital-symbol"></i> IPPR-MC-SPACE V4.0 (Syntax Integrated)</div>
            <div class="nav-tabs">
                <div class="nav-tab active" onclick="switchTab('3d')"><i class="fas fa-cube"></i> 3D 规划</div>
                <div class="nav-tab" onclick="switchTab('report')"><i class="fas fa-chart-pie"></i> 效能报告</div>
            </div>
            <div class="flex gap-2">
                <button class="btn btn-ghost" onclick="toggleTheme()" title="切换主题"><i class="fas fa-moon" id="theme-icon"></i></button>
                <div style="width:1px; background:var(--border-color); margin:0 4px;"></div>
                <button class="btn btn-ai" onclick="openAIModal()"><i class="fas fa-magic"></i> AI Architect</button>
                <button class="btn btn-secondary" onclick="exportData()"><i class="fas fa-download"></i> 导出</button>
                <button class="btn btn-primary" onclick="startGenerativeDesign()"><i class="fas fa-dice"></i> 生成式设计</button>
            </div>
        </nav>

        <!-- 3D VIEW -->
        <div id="view-3d" class="view-section active">
            <div id="canvas-container" tabindex="0"></div>
            <div id="labels-layer" style="position: absolute; inset: 0; pointer-events: none; overflow: hidden;"></div>
            <div id="selection-box"></div>

            <div id="view-controls">
                <div class="v-btn" onclick="setView('south')">南</div>
                <div class="v-btn" onclick="setView('north')">北</div>
                <div class="v-btn" onclick="setView('east')">东</div>
                <div class="v-btn" onclick="setView('west')">西</div>
                <div class="v-btn" onclick="setView('top')">顶</div>
                <div class="v-btn" onclick="resetView()">重置</div>
                <div style="width:1px; height:20px; background:var(--border-color); margin:0 4px;"></div>
                <div class="v-btn-icon" id="btn-daylight" onclick="toggleDaylightMode()" title="采光热力图"><i class="fas fa-sun"></i></div>
                <div class="v-btn-icon" id="btn-syntax" onclick="toggleSyntaxMode()" title="空间句法热力图 (Integration/Choice)"><i class="fas fa-network-wired"></i></div>
                <div class="v-btn-icon active" id="btn-labels" onclick="toggleLabels()" title="距离标注"><i class="fas fa-ruler-combined"></i></div>
                
                <div style="display:flex; align-items:center; background:var(--border-faint); border-radius:14px; padding:2px; border:1px solid var(--border-color);">
                    <div style="padding:0 8px; font-size:11px; color:var(--text-muted);"><i class="fas fa-atom"></i></div>
                    <div class="v-btn active" id="btn-phy-0" onclick="setPhysicsMode(0)" style="border-radius:10px;">关</div>
                    <div class="v-btn" id="btn-phy-1" onclick="setPhysicsMode(1)" style="border-radius:10px;">L1</div>
                    <div class="v-btn" id="btn-phy-2" onclick="setPhysicsMode(2)" style="border-radius:10px;">L2</div>
                </div>
            </div>
            
            <div id="slice-panel">
                <div class="flex items-center gap-3">
                    <span class="text-sm font-bold text-blue-400 flex items-center gap-2"><i class="fas fa-layer-group"></i> 切片</span>
                    <label class="slice-toggle-wrapper">
                        <input type="checkbox" class="slice-checkbox" id="slice-toggle" onchange="toggleSliceMode()">
                        <span class="slice-slider-bg"></span>
                    </label>
                </div>
                <div class="flex-1 flex items-center gap-3">
                    <span class="text-xs font-mono" style="color:var(--text-muted)">0m</span>
                    <input type="range" id="slice-slider" min="0" max="100" value="0" step="1" oninput="updateSliceHeight(this.value)">
                    <span class="text-xs font-mono" style="color:var(--text-muted)">100m</span>
                </div>
                <div class="w-16 text-right"><span id="slice-display" class="text-xs font-mono font-bold" style="color:var(--text-main)">ALL</span></div>
            </div>
            
            <div id="shortcut-hint">快捷键: 鼠标左键拖拽为空白框选，点中体块为移动(Shift锁定) | Ctrl+Z 撤销 | Del 删除</div>

            <div id="zoom-controls">
                <button class="btn-zoom" onclick="zoomIn()" title="放大"><i class="fas fa-plus"></i></button>
                <button class="btn-zoom" onclick="zoomOut()" title="缩小"><i class="fas fa-minus"></i></button>
            </div>

            <!-- Analysis Dashboard -->
            <div id="analysis-dashboard">
                <div class="kpi-card" id="kpi-flow">
                    <div class="kpi-title">流程阻力 (FRI)</div>
                    <div class="kpi-value">0.0</div>
                    <div class="kpi-sub">加权距离总量</div>
                </div>
                <div class="kpi-card" id="kpi-vh">
                    <div class="kpi-title">垂直效能 (VEC)</div>
                    <div class="kpi-value">0.00</div>
                    <div class="kpi-sub">电梯等待惩罚</div>
                </div>
                <div class="kpi-card" id="kpi-light">
                    <div class="kpi-title">黑房间</div>
                    <div class="kpi-value">0</div>
                    <div class="kpi-sub">个无采光</div>
                </div>
            </div>

            <div id="legend">
                <div class="legend-item"><div class="legend-dot" style="background:#ef4444"></div>强关联 (5)</div>
                <div class="legend-item"><div class="legend-dot" style="background:#3b82f6"></div>弱关联 (1-3)</div>
                <div class="legend-item"><div class="legend-dot" style="background:#f97316"></div>L2 功能点</div>
                <div class="legend-item"><div class="legend-dot" style="background:#cbd5e1"></div>水平走廊</div>
                <div class="legend-item"><div class="legend-dot" style="background:#64748b"></div>垂直交通核</div>
            </div>
            
            <!-- Left Sidebar -->
            <div id="sidebar-left" class="sidebar left panel">
                <div class="sidebar-header">
                    <span class="text-sm font-bold" style="color:var(--text-main)"><i class="fas fa-project-diagram mr-2"></i>关联矩阵</span>
                </div>
                <div class="toggle-btn" onclick="toggleSidebar('left')"><i class="fas fa-chevron-left" id="icon-left"></i></div>
                <div class="sidebar-content">
                    <div class="matrix-tabs">
                        <div class="matrix-tab active" id="tab-l1" onclick="switchMatrixLevel('l1')">L1 科室 (Macro)</div>
                        <div class="matrix-tab" id="tab-l2" onclick="switchMatrixLevel('l2')">L2 功能点 (Quantum)</div>
                    </div>
                    
                    <div class="text-[10px] mb-2" style="color:var(--text-muted)">
                        <span id="matrix-hint">设置科室间吸引力 (0-5)</span>
                    </div>
                    <div id="matrix-editor" class="matrix-container mb-4"></div>
                    
                    <div class="border-t pt-4 mt-2" style="border-color:var(--border-color)">
                        <div class="text-sm font-bold mb-2" style="color:var(--text-main)"><i class="fas fa-list mr-2"></i>清单</div>
                        <div id="dept-list" class="flex flex-col gap-1"></div>
                        <button class="btn btn-secondary w-full mt-3" onclick="addNewDept()"><i class="fas fa-plus"></i> 添加科室</button>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar -->
            <div id="sidebar-right" class="sidebar right panel">
                <div class="sidebar-header">
                    <span class="text-sm font-bold" style="color:var(--text-main)"><i class="fas fa-sliders-h mr-2"></i>属性与诊断</span>
                </div>
                <div class="toggle-btn" onclick="toggleSidebar('right')"><i class="fas fa-chevron-right" id="icon-right"></i></div>
                <div class="sidebar-content">
                    <div id="selection-panel" style="display:none;">
                        <div class="form-group">
                            <label class="form-label">名称</label>
                            <input type="text" id="prop-name" class="form-input">
                        </div>
                        <div class="grid grid-cols-2 gap-2 mb-2">
                            <div class="form-group">
                                <label class="form-label">颜色</label>
                                <input type="color" id="prop-color" class="form-input h-8 p-0">
                            </div>
                            <div class="form-group">
                                <label class="form-label">床位数</label>
                                <input type="number" id="prop-beds" class="form-input">
                            </div>
                        </div>

                        <!-- Fixed Toggle -->
                        <div class="flex items-center gap-2 mb-3 bg-white/5 p-2 rounded border border-white/10">
                            <input type="checkbox" id="prop-fixed" class="w-4 h-4 accent-blue-500 cursor-pointer">
                            <label for="prop-fixed" class="text-[10px] text-white cursor-pointer select-none font-bold">锁定位置 (固定)</label>
                        </div>
                        
                        <!-- Shape Edit Toggle -->
                        <div class="bg-white/5 rounded p-2 mb-3 border border-white/10">
                            <div class="flex justify-between items-center">
                                <label class="text-[10px] font-bold text-green-400">几何形状</label>
                                <button class="btn btn-ghost px-2 py-1 text-[10px]" id="btn-edit-shape" onclick="toggleShapeEdit()">
                                    <i class="fas fa-draw-polygon"></i> 编辑形状
                                </button>
                            </div>
                        </div>

                        <!-- Space Syntax Stats (NEW) -->
                        <div class="bg-white/5 rounded p-2 mb-3 border border-white/10">
                             <div class="text-[10px] font-bold text-purple-400 mb-2">空间句法指标 (Space Syntax)</div>
                             <div class="grid grid-cols-2 gap-2 text-[10px]">
                                 <div class="flex justify-between">
                                     <span class="text-gray-400" title="集成度/可达性: 反映全局中心性">集成度:</span>
                                     <span id="syn-int" class="syntax-val text-white">0.0</span>
                                 </div>
                                 <div class="flex justify-between">
                                     <span class="text-gray-400" title="穿行度/选择度: 反映作为交通枢纽的潜力">穿行度:</span>
                                     <span id="syn-ch" class="syntax-val text-white">0.0</span>
                                 </div>
                                 <div class="flex justify-between">
                                     <span class="text-gray-400" title="连接值: 直接相连的空间数">连接值:</span>
                                     <span id="syn-con" class="syntax-val text-white">0</span>
                                 </div>
                                 <div class="flex justify-between">
                                     <span class="text-gray-400" title="控制值: 对相邻空间的控制力">控制值:</span>
                                     <span id="syn-ctr" class="syntax-val text-white">0.0</span>
                                 </div>
                             </div>
                        </div>

                        <!-- L2 Management -->
                        <div class="bg-white/5 rounded p-2 mb-3 border border-white/10">
                            <div class="flex justify-between items-center mb-2">
                                <label class="text-[10px] font-bold text-blue-400">二级功能点 (L2)</label>
                                <button class="btn btn-orange px-2 py-1 text-[10px]" onclick="addL2Unit()"><i class="fas fa-plus"></i> 添加</button>
                            </div>
                            <div id="l2-units-list" class="flex flex-col gap-1 max-h-[200px] overflow-y-auto"></div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">面积 (m²)</label>
                            <input type="number" id="prop-area-input" class="form-input" placeholder="输入面积自动计算尺寸" disabled title="形状编辑模式下自动计算">
                        </div>
                        <div class="grid grid-cols-3 gap-2">
                            <div class="form-group"><label class="form-label">宽(X)</label><input type="number" id="prop-w" class="form-input"></div>
                            <div class="form-group"><label class="form-label">高(Y)</label><input type="number" id="prop-h" class="form-input"></div>
                            <div class="form-group"><label class="form-label">深(Z)</label><input type="number" id="prop-d" class="form-input"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">楼层高度 (Y Pos)</label>
                            <input type="number" id="prop-y" class="form-input">
                        </div>
                        <div class="text-xs flex justify-between mt-1 mb-4" style="color:var(--text-muted)">
                            <span>面积: <span id="prop-area" class="font-mono" style="color:var(--text-main)">0</span> m²</span>
                            <span>体积: <span id="prop-vol" class="font-mono" style="color:var(--text-main)">0</span> m³</span>
                        </div>
                        <button class="btn btn-danger w-full" onclick="deleteSelection()">删除科室</button>
                    </div>
                    
                    <div id="multi-selection-panel" style="display:none;" class="text-center py-6">
                        <div class="text-xl font-bold text-blue-400 mb-2"><span id="multi-count">0</span> 个选中</div>
                        <div class="text-xs mb-4" style="color:var(--text-muted)">已选中多个科室</div>
                        <button class="btn btn-danger btn-sm" onclick="deleteSelection()">批量删除</button>
                    </div>

                    <div id="no-selection" class="text-center py-8 text-xs border border-dashed rounded" style="color:var(--text-muted); border-color:var(--border-color)">
                        未选择对象<br>拖拽框选或点击模型
                    </div>

                    <div class="border-t pt-4 mt-4" style="border-color:var(--border-color)">
                        <div class="text-sm font-bold mb-2" style="color:var(--text-main)"><i class="fas fa-stethoscope mr-2"></i>智能诊断</div>
                        <div id="diagnostics-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI Consultant Modal -->
        <div id="ai-modal" class="panel" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:600px; height:70vh; z-index:5000; flex-direction:column; overflow:hidden;">
            <div class="sidebar-header" style="background:linear-gradient(to right, rgba(99, 102, 241, 0.1), transparent);">
                <span class="text-sm font-bold flex items-center gap-2" style="color:#a855f7"><i class="fas fa-magic"></i>Gemini AI Architect</span>
                <button onclick="closeAIModal()" class="text-gray-400 hover:text-white"><i class="fas fa-times"></i></button>
            </div>
            <div id="ai-chat-content" class="p-4" style="flex:1; overflow-y:auto; display:flex; flex-direction:column; gap:10px;">
                <div class="msg-bot msg-bubble">
                    Hello! I am your AI Architect Assistant connected to your 3D layout. 
                    <br><br>I can analyze your hospital plan for CIBSE/GB compliance or answer specific questions about department placement.
                </div>
            </div>
            <div class="p-3 border-t border-gray-700 bg-black/20 flex flex-col gap-2">
                <button class="btn btn-ai w-full mb-1" onclick="runAIAnalysis()"><i class="fas fa-search-location mr-2"></i> Generate Full Critique Report</button>
                <div class="flex gap-2">
                    <input type="text" id="ai-chat-input" class="form-input" placeholder="Ask about the layout...">
                    <button class="btn btn-secondary" onclick="sendAIChat()"><i class="fas fa-paper-plane"></i></button>
                </div>
            </div>
        </div>

        <!-- REPORT VIEW -->
        <div id="view-report" class="view-section" style="background:var(--bg-app); overflow-y:auto; padding:40px;">
             <div class="max-w-5xl mx-auto">
                <h2 class="text-2xl font-bold mb-6" style="color:var(--text-main)">空间效能分析报告</h2>
                 <!-- Charts and Tables -->
                 <div class="grid grid-cols-2 gap-6 mb-8">
                     <div class="panel p-4">
                         <h3 class="text-sm font-bold mb-4" style="color:var(--text-muted)">功能面积占比</h3>
                         <div style="height:250px"><canvas id="areaChart"></canvas></div>
                     </div>
                     <div class="panel p-4">
                         <h3 class="text-sm font-bold mb-4" style="color:var(--text-muted)">流线效率分析</h3>
                         <div style="height:230px"><canvas id="flowChart"></canvas></div>
                     </div>
                 </div>
                 
                 <!-- Compliance Table -->
                 <div class="panel p-6 mb-8">
                    <h3 class="text-lg font-bold mb-4" style="color:var(--text-main)">面积配比与国标对标分析 (GB51039)</h3>
                    <table class="w-full text-sm text-left" style="color:var(--text-muted)">
                        <thead>
                            <tr>
                                <th class="report-header">功能区域</th>
                                <th class="report-header">设计面积 (m²)</th>
                                <th class="report-header">设计占比</th>
                                <th class="report-header">国标参考范围</th>
                                <th class="report-header">合规性评价</th>
                            </tr>
                        </thead>
                        <tbody id="compliance-table-body"></tbody>
                    </table>
                 </div>

                 <div class="panel p-6 mb-8">
                     <h3 class="text-lg font-bold mb-4" style="color:var(--text-main)">详细效能指标</h3>
                     <table class="w-full text-sm text-left" style="color:var(--text-muted)">
                         <thead>
                            <tr><th class="report-header">指标项</th><th class="report-header">当前值</th><th class="report-header">参考标准</th><th class="report-header">评价</th></tr>
                         </thead>
                         <tbody id="report-table-body"></tbody>
                     </table>
                 </div>
             </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Gemini API Setup ---
        const apiKey = ""; 
        const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";

        // --- Data & State ---
        // GB Standards: Generic Hospital Category Estimations
        const gbBenchmarks = {
            'emergency': { label: '急诊部', min: 2, max: 5, color: '#ef4444' },
            'outpatient': { label: '门诊部', min: 10, max: 15, color: '#22c55e' },
            'inpatient': { label: '住院部', min: 35, max: 45, color: '#eab308' },
            'medtech': { label: '医技科室', min: 15, max: 20, color: '#3b82f6' },
            'admin': { label: '行政/保障', min: 10, max: 25, color: '#64748b' },
            'public': { label: '公共交通', min: 20, max: 35, color: '#94a3b8' }
        };

        const initialDepts = [
            { id: 'er', name: '急诊部', cat:'emergency', color: '#ef4444', w: 40, h: 5, d: 30, x: -50, y: 2.5, z: 20, beds: 30, subNodes: [{id:'er_triage', name:'分诊台', type:'人员', x:0, y:0, z:10}, {id:'er_resus', name:'复苏室', type:'设备', x:10, y:0, z:-5}] },
            { id: 'img', name: '医技中心', cat:'medtech', color: '#3b82f6', w: 30, h: 5, d: 25, x: 0, y: 2.5, z: 20, beds: 0, subNodes: [{id:'img_ct', name:'CT室', type:'设备', x:0, y:0, z:0}] },
            { id: 'op', name: '门诊部', cat:'outpatient', color: '#22c55e', w: 60, h: 8, d: 40, x: 0, y: 4, z: 70, beds: 0, subNodes: [] },
            { id: 'surg', name: '手术部', cat:'medtech', color: '#a855f7', w: 40, h: 6, d: 40, x: 0, y: 10, z: 0, beds: 0, subNodes: [] },
            { id: 'icu', name: 'ICU', cat:'medtech', color: '#f97316', w: 25, h: 5, d: 20, x: -40, y: 10, z: 0, beds: 20, subNodes: [] },
            { id: 'ward1', name: '住院A', cat:'inpatient', color: '#eab308', w: 60, h: 4, d: 20, x: 0, y: 20, z: -30, beds: 50, subNodes: [] },
            { id: 'ward2', name: '住院B', cat:'inpatient', color: '#eab308', w: 60, h: 4, d: 20, x: 0, y: 24, z: -30, beds: 50, subNodes: [] },
            { id: 'log', name: '后勤供应', cat:'admin', color: '#64748b', w: 30, h: 6, d: 30, x: 50, y: 3, z: -20, beds: 0, subNodes: [] }
        ];

        let blocks = [], connections = [], coreMeshes = [], corridorMeshes = [], l2Meshes = [], l2Lines = [];
        let shapeHandles = []; // For Edit Mode
        let matrix = {}; 
        let l2Matrix = {}; 
        let selectedBlocks = [];
        let clipboard = [];
        let historyStack = [];
        let totalPublicArea = 0;
        
        let isDaylightMode = false;
        // Space Syntax State
        let syntaxMode = 'none'; // 'none', 'integration', 'choice'
        
        let showDistanceLabels = true; 
        let physicsMode = 0; 
        let matrixLevel = 'l1'; 
        let isSliceMode = false;
        let sliceY = 0;
        let currentTheme = 'dark';
        let isShapeEditMode = false;
        
        let areaChart, flowChart;
        let windowAnalysisData = {}; 

        let generativeDesignRunning = false;
        let candidateSolutions = [];
        let currentIteration = 0;
        let maxIterations = 100;
        let bestSolutions = [];

        // Interaction Variables
        let isDragging = false;
        let isSelecting = false;
        let draggedObject = null;
        let startSelectionCoords = { x: 0, y: 0 };
        const dragOffset = new THREE.Vector3();
        const dragStartPos = new THREE.Vector3(); 
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const selectionBox = document.getElementById('selection-box');

        // Scene Setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene(); 
        scene.background = new THREE.Color(0x0f172a);
        
        const camera = new THREE.OrthographicCamera(-1,1,1,-1,1,5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.PAN, RIGHT: THREE.MOUSE.ROTATE }; 

        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.addEventListener('dragging-changed', e => { 
            controls.enabled = !e.value; 
            if(e.value) {
                // Drag start
            } else {
                // Drag end
                saveState();
                updateSystem();
            }
        });
        // 监听 Gumball 的变化，实时更新连接线和标签
        transformControl.addEventListener('change', () => {
            if(transformControl.object) {
                updateSystem(); // 实时更新连接线、L2结构等
            }
        });
        scene.add(transformControl);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        let grid = new THREE.GridHelper(400, 40, 0x334155, 0x1e293b);
        scene.add(grid);

        // --- Core Functions ---

        function init() {
            setRelation('er', 'img', 5);
            setRelation('er', 'surg', 4);
            setRelation('op', 'img', 3);
            setRelation('surg', 'icu', 5);
            setRelation('surg', 'img', 3);

            initialDepts.forEach(createBlock);
            setL2Relation('er_resus', 'img_ct', 5);

            updateSystem();
            renderMatrix();
            window.addEventListener('resize', onResize);
            onResize();
            resetView();
            animate();
            saveState(); 
        }

        window.toggleTheme = () => {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', currentTheme);
            const btn = document.getElementById('theme-icon');
            
            if(currentTheme === 'light') {
                btn.className = 'fas fa-sun';
                scene.background = new THREE.Color(0xf1f5f9);
                scene.remove(grid);
                grid = new THREE.GridHelper(400, 40, 0xcbd5e1, 0xe2e8f0);
                scene.add(grid);
            } else {
                btn.className = 'fas fa-moon';
                scene.background = new THREE.Color(0x0f172a);
                scene.remove(grid);
                grid = new THREE.GridHelper(400, 40, 0x334155, 0x1e293b);
                scene.add(grid);
            }
            updateConnections();
            if(document.getElementById('view-report').classList.contains('active')) generateReport();
        };

        // --- Extrusion Logic ---
        function generateExtrudedGeometry(points, height) {
            const shape = new THREE.Shape();
            shape.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) shape.lineTo(points[i].x, points[i].y);
            shape.lineTo(points[0].x, points[0].y);

            const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
            // Center the geometry so (0,0) is center of block, extruded along Y
            geometry.translate(0, 0, -height/2); 
            geometry.rotateX(-Math.PI / 2); 
            return geometry;
        }

        function createBlock(data) {
            // Default rectangular shape if no points provided
            if(!data.points) {
                const hw = data.w/2;
                const hd = data.d/2;
                data.points = [
                    {x: -hw, y: -hd},
                    {x: hw, y: -hd},
                    {x: hw, y: hd},
                    {x: -hw, y: hd}
                ];
            }

            const geometry = generateExtrudedGeometry(data.points, data.h);
            const mat = new THREE.MeshStandardMaterial({ 
                color: data.color, roughness: 0.4, metalness: 0.1, transparent: true, opacity: 0.9 
            });
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.position.set(data.x, data.y, data.z);
            // NOTE: We don't scale ExtrudeGeometry like BoxGeometry. Scale should be 1,1,1
            // Scale logic is now handled by regenerating geometry.
            mesh.scale.set(1, 1, 1); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            if (!data.subNodes) data.subNodes = [];
            if (!data.cat) data.cat = 'admin';
            
            // Initial fixed state
            if (data.fixed === undefined) data.fixed = false;

            // Space Syntax Data Holders
            data.syntax = { integration: 0, choice: 0, connectivity: 0, control: 0 };

            mesh.userData = { ...data, originalColor: data.color };
            scene.add(mesh);
            blocks.push(mesh);
            return mesh;
        }

        function updateBlockGeometry(block) {
            // Dispose old
            block.geometry.dispose();
            // Generate new based on userData
            const newGeo = generateExtrudedGeometry(block.userData.points, block.userData.h);
            block.geometry = newGeo;
        }

        // --- L1/L2 Matrix Helpers ---
        function setRelation(id1, id2, str) {
            if(id1 === id2) return;
            const k = id1 < id2 ? `${id1}_${id2}` : `${id2}_${id1}`;
            matrix[k] = parseInt(str);
        }
        function getRelation(id1, id2) {
            const k = id1 < id2 ? `${id1}_${id2}` : `${id2}_${id1}`;
            return matrix[k] || 0;
        }
        function setL2Relation(id1, id2, str) {
            if(id1 === id2) return;
            const k = id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`;
            l2Matrix[k] = parseInt(str);
        }
        function getL2Relation(id1, id2) {
            const k = id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`;
            return l2Matrix[k] || 0;
        }

        function updateSystem() {
            updateConnections();
            updateL2Visuals();
            updateAutoStructures();
            analyzeMetrics();
            
            // --- Space Syntax Calculation ---
            calculateSpaceSyntax();
            
            updateLabels();
            updateDiagnostics();
            if(isDaylightMode) runDaylightAnalysis();
            if(syntaxMode !== 'none') runSyntaxVisuals(); // Update visual if syntax mode active
            updateSliceView();
            if(isShapeEditMode) updateShapeHandles();
        }

        // --- Space Syntax Logic (NEW) ---
        function calculateSpaceSyntax() {
            const nodes = blocks.map(b => b.userData.id);
            const n = nodes.length;
            if (n < 2) return;

            // 1. Build Adjacency Graph (Unweighted for topological steps)
            // We define "Connection" as Matrix Relation > 0 OR Distance < Threshold
            const adj = {};
            nodes.forEach(id => adj[id] = []);

            for(let i=0; i<blocks.length; i++) {
                for(let j=i+1; j<blocks.length; j++) {
                    const b1 = blocks[i];
                    const b2 = blocks[j];
                    const id1 = b1.userData.id;
                    const id2 = b2.userData.id;
                    
                    // Functional link (Matrix)
                    const rel = getRelation(id1, id2);
                    
                    // Spatial link (Distance < threshold, e.g., 20m + touching logic)
                    // Simplified: if relation exists OR they are very close
                    const dist = b1.position.distanceTo(b2.position);
                    const spatialLink = dist < (Math.max(b1.userData.w, b1.userData.d) + Math.max(b2.userData.w, b2.userData.d)) * 0.6;

                    if (rel > 0 || spatialLink) {
                        adj[id1].push(id2);
                        adj[id2].push(id1);
                    }
                }
            }

            // 2. Connectivity (Degree) & Control
            const degrees = {};
            blocks.forEach(b => {
                const id = b.userData.id;
                const k = adj[id].length;
                degrees[id] = k;
                b.userData.syntax.connectivity = k;
            });

            // Control Value: sum(1/degree(neighbor))
            blocks.forEach(b => {
                const id = b.userData.id;
                let ctrl = 0;
                adj[id].forEach(nbr => {
                    if (degrees[nbr] > 0) ctrl += 1 / degrees[nbr];
                });
                b.userData.syntax.control = ctrl;
            });

            // 3. Integration (Global) & Choice (Betweenness)
            // Shortest Path (BFS)
            const choiceCounts = {}; // node -> count
            nodes.forEach(id => choiceCounts[id] = 0);

            blocks.forEach(startBlock => {
                const s = startBlock.userData.id;
                let totalDepth = 0;
                
                // BFS for Depth and Path Counting
                const queue = [s];
                const dist = {};
                const prev = {}; // for path reconstruction
                nodes.forEach(n => { dist[n] = Infinity; prev[n] = []; });
                dist[s] = 0;

                while(queue.length > 0) {
                    const u = queue.shift();
                    adj[u].forEach(v => {
                        if (dist[v] === Infinity) {
                            dist[v] = dist[u] + 1;
                            prev[v] = [u];
                            queue.push(v);
                        } else if (dist[v] === dist[u] + 1) {
                            prev[v].push(u);
                        }
                    });
                }

                // Sum Total Depth for Integration
                let reachableCount = 0;
                nodes.forEach(target => {
                    if(target !== s && dist[target] !== Infinity) {
                        totalDepth += dist[target];
                        reachableCount++;
                    }
                });

                // Calculate Mean Depth & Integration (HH)
                // Integration = 1 / Mean Depth (Simplified)
                // RRA (Real Relative Asymmetry) logic is complex, using simple 1/MD for visual
                const md = reachableCount > 0 ? totalDepth / reachableCount : Infinity;
                startBlock.userData.syntax.integration = md > 0 ? (1 / md) * 10 : 0; // Scale for readability

                // Choice Calculation (Betweenness approximation based on geodesics)
                // For every target t != s, backtrack to find paths
                // This is a simplified "stress centrality"
                nodes.forEach(t => {
                    if (t === s || dist[t] === Infinity) return;
                    let curr = t;
                    // Simple backtrack one path (simplification for real-time)
                    // Full Betweenness requires Brandes algorithm, computationally heavy for JS loop
                    // We stick to simple path counting for now
                    while (prev[curr] && prev[curr].length > 0) {
                        curr = prev[curr][0]; // Take primary parent
                        if (curr !== s) choiceCounts[curr]++;
                    }
                });
            });

            // Normalize Choice
            const maxChoice = Math.max(...Object.values(choiceCounts), 1);
            blocks.forEach(b => {
                b.userData.syntax.choice = choiceCounts[b.userData.id];
            });

            // Refresh UI if selected
            if (selectedBlocks.length === 1) {
                fillSyntaxPanel(selectedBlocks[0]);
            }
        }

        function updateConnections() {
            connections.forEach(c => { scene.remove(c.line); c.label.remove(); });
            connections = [];
            const labelLayer = document.getElementById('labels-layer');

            for(let i=0; i<blocks.length; i++) {
                for(let j=i+1; j<blocks.length; j++) {
                    const b1 = blocks[i]; const b2 = blocks[j];
                    const strength = getRelation(b1.userData.id, b2.userData.id);
                    
                    if(strength > 0) {
                        const p1 = b1.position; const p2 = b2.position;
                        const pts = [new THREE.Vector3(p1.x, p1.y, p1.z), new THREE.Vector3(p2.x, p1.y, p1.z), new THREE.Vector3(p2.x, p1.y, p2.z), new THREE.Vector3(p2.x, p2.y, p2.z)];
                        const geo = new THREE.BufferGeometry().setFromPoints(pts);
                        const color = strength >= 4 ? 0xef4444 : (strength >= 2 ? 0x3b82f6 : 0x94a3b8);
                        const mat = new THREE.LineBasicMaterial({ color: color, opacity: strength/5, transparent: true });
                        const line = new THREE.Line(geo, mat);
                        scene.add(line);

                        const distH = Math.abs(p1.x - p2.x) + Math.abs(p1.z - p2.z);
                        const distV = Math.abs(p1.y - p2.y);
                        const distTotal = distH + distV;

                        const div = document.createElement('div');
                        div.className = 'dist-label';
                        div.innerText = distTotal.toFixed(0) + "m";
                        div.style.color = strength >= 4 ? '#ef4444' : (currentTheme === 'light' ? '#334155' : '#e2e8f0');
                        div.style.display = showDistanceLabels ? 'block' : 'none';
                        labelLayer.appendChild(div);

                        connections.push({ line, label: div, b1, b2, strength, distH, distV, distTotal, mid: new THREE.Vector3().lerpVectors(p1, p2, 0.5) });
                    }
                }
            }
        }

        function updateAutoStructures() {
            coreMeshes.forEach(m => { scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
            corridorMeshes.forEach(m => { scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
            coreMeshes = []; corridorMeshes = [];
            totalPublicArea = 0;

            if(isDragging) return;

            const hSegs = [];
            const rawShafts = [];
            connections.forEach(c => {
                if (c.strength > 0 && c.distV > 4) { 
                    const p1 = c.b1.position;
                    const p2 = c.b2.position;
                    const shaftX = (p1.x + p2.x) / 2;
                    const shaftZ = (p1.z + p2.z) / 2;
                    const minY = Math.min(p1.y, p2.y);
                    const maxY = Math.max(p1.y, p2.y);
                    rawShafts.push({ x: shaftX, z: shaftZ, minY, maxY, strength: c.strength });
                }
                
                if (Math.abs(c.b1.position.y - c.b2.position.y) < 2) {
                    const y = c.b1.position.y - c.b1.userData.h/2 + 1; 
                    const p1 = c.b1.position; const p2 = c.b2.position;
                    if (Math.abs(p1.x - p2.x) > 1) hSegs.push({ axis: 'x', y: y, z: p1.z, min: Math.min(p1.x, p2.x), max: Math.max(p1.x, p2.x) });
                    if (Math.abs(p1.z - p2.z) > 1) hSegs.push({ axis: 'z', y: y, x: p2.x, min: Math.min(p1.z, p2.z), max: Math.max(p1.z, p2.z) });
                }
            });

            const mergedShafts = [];
            rawShafts.forEach(raw => {
                let merged = false;
                for(let bank of mergedShafts) {
                    const dist = Math.sqrt((raw.x - bank.x)**2 + (raw.z - bank.z)**2);
                    if (dist < 15) { 
                        bank.x = (bank.x + raw.x) / 2;
                        bank.z = (bank.z + raw.z) / 2;
                        bank.minY = Math.min(bank.minY, raw.minY);
                        bank.maxY = Math.max(bank.maxY, raw.maxY);
                        bank.strength = Math.max(bank.strength, raw.strength);
                        merged = true;
                        break;
                    }
                }
                if (!merged) mergedShafts.push(raw);
            });

            mergedShafts.forEach(bank => {
                const height = bank.maxY - bank.minY + 4;
                const width = bank.strength > 3 ? 6 : 4;
                const depth = bank.strength > 3 ? 6 : 4;
                const geo = new THREE.BoxGeometry(width, height, depth);
                const mat = new THREE.MeshBasicMaterial({ color: 0x64748b, transparent: true, opacity: 0.5 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(bank.x, (bank.minY + bank.maxY)/2, bank.z);
                scene.add(mesh);
                coreMeshes.push(mesh);
                totalPublicArea += width * depth * (height / 4); 
            });

            hSegs.forEach(s => {
                const len = s.max - s.min;
                if(len < 2) return;
                const w = 2; 
                const geo = s.axis === 'x' ? new THREE.BoxGeometry(len, 0.5, w) : new THREE.BoxGeometry(w, 0.5, len);
                const mat = new THREE.MeshBasicMaterial({ color: 0xcbd5e1, transparent: true, opacity: 0.4 });
                const mesh = new THREE.Mesh(geo, mat);
                if (s.axis === 'x') mesh.position.set(s.min + len/2, s.y, s.z);
                else mesh.position.set(s.x, s.y, s.min + len/2);
                scene.add(mesh);
                corridorMeshes.push(mesh);
                totalPublicArea += len * w;
            });
        }

        // --- Interaction Logic ---
        
        container.addEventListener('mousedown', onMouseDown);
        container.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        container.addEventListener('contextmenu', (e) => e.preventDefault());

        function onMouseDown(e) {
            if(e.button !== 0) return;
            
            // [修复] 如果正悬停在 Gumball (变换控制器) 上，不要执行选择/取消选择逻辑
            // TransformControls 的 axis 属性在鼠标悬停在轴上时会有值 (如 'X', 'Y', 'XY' 等)，否则为 null
            if (transformControl.axis) return;

            const rect = container.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // 1. Check for Shape Handles first (Custom Drag for Vertex Editing)
            if(isShapeEditMode && shapeHandles.length > 0) {
                const intersectsH = raycaster.intersectObjects(shapeHandles);
                if(intersectsH.length > 0) {
                    
                    // [ADD VERTEX LOGIC]
                    if (intersectsH[0].object.userData.isGhost) {
                        const ghost = intersectsH[0].object;
                        const block = ghost.userData.parentBlock;
                        const idx = ghost.userData.index;
                        
                        // Insert new point at midpoint
                        const p1 = block.userData.points[idx];
                        const p2 = block.userData.points[(idx+1)%block.userData.points.length];
                        const newPt = { x: (p1.x+p2.x)/2, y: (p1.y+p2.y)/2 };

                        block.userData.points.splice(idx + 1, 0, newPt);
                        updateBlockGeometry(block);
                        createShapeHandles(block); // Refresh to make new real handle

                        // Find the new real handle to drag immediately
                        const newHandle = shapeHandles.find(h => !h.userData.isGhost && h.userData.index === idx + 1);
                        
                        controls.enabled = false;
                        isDragging = true;
                        draggedObject = newHandle;
                        const ip = intersectsH[0].point;
                        dragPlane.constant = -ip.y;
                        return;
                    }

                    controls.enabled = false;
                    isDragging = true;
                    draggedObject = intersectsH[0].object; // A normal handle
                    const ip = intersectsH[0].point;
                    dragPlane.constant = -ip.y;
                    return;
                }
            }

            // 2. Check Blocks (Select Only - Gumball handles drag)
            const intersects = raycaster.intersectObjects(blocks);
            if(intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                // 如果点击了当前未选中的体块，则选中它并显示 Gumball
                // 如果已经选中了该体块，不做任何操作（让 Gumball 自己处理点击事件，或者允许 OrbitControls 工作）
                if(!selectedBlocks.includes(clickedObject)) {
                    handleSelection([clickedObject]);
                }
                
                // 注意：这里不再设置 isDragging = true，也不禁用 controls
                // 这样 Gumball (TransformControls) 才能接收到事件并处理轴向拖拽
            } else {
                // 3. Background click -> Box Select
                isDragging = false;
                isSelecting = true;
                startSelectionCoords = { x: e.clientX, y: e.clientY };
                selectionBox.style.display = 'block';
                selectionBox.style.left = e.clientX + 'px';
                selectionBox.style.top = e.clientY + 'px';
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                
                // 点击空白处取消选择
                handleSelection([]);
            }
        }

        function onMouseMove(e) {
            // Only handle custom dragging for Shape Handles (Vertices)
            if (isDragging && draggedObject && draggedObject.userData.isHandle) {
                const rect = container.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                
                if(intersectPoint) {
                    const handle = draggedObject;
                    const block = selectedBlocks[0]; 
                    // Move handle on XZ plane relative to block center
                    const localPos = intersectPoint.clone().sub(block.position);
                    
                    if (e.shiftKey) {
                        // Simple axis snap for vertices if needed, or free move
                        if(Math.abs(localPos.x) < 2) localPos.x = 0;
                        if(Math.abs(localPos.z) < 2) localPos.z = 0;
                    }

                    handle.position.copy(intersectPoint); 
                    
                    // Update point
                    const ptIndex = handle.userData.index;
                    block.userData.points[ptIndex].x = localPos.x;
                    block.userData.points[ptIndex].y = localPos.z; 
                    
                    updateBlockGeometry(block);
                    return;
                }
            } 
            
            // Box Select Visual Update
            if (isSelecting) {
                const left = Math.min(startSelectionCoords.x, e.clientX);
                const top = Math.min(startSelectionCoords.y, e.clientY);
                const width = Math.abs(e.clientX - startSelectionCoords.x);
                const height = Math.abs(e.clientY - startSelectionCoords.y);
                
                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
            }
        }

        function onMouseUp(e) {
            if(isDragging) {
                // Shape handle drag end
                isDragging = false;
                draggedObject = null;
                controls.enabled = true;
                if(isShapeEditMode) updateShapeHandles(); 
                saveState();
            } else if (isSelecting) {
                // Box select end
                isSelecting = false;
                selectionBox.style.display = 'none';
                
                const rect = container.getBoundingClientRect();
                const left = Math.min(startSelectionCoords.x, e.clientX);
                const top = Math.min(startSelectionCoords.y, e.clientY);
                const width = Math.abs(e.clientX - startSelectionCoords.x);
                const height = Math.abs(e.clientY - startSelectionCoords.y);
                
                if (width > 5 || height > 5) {
                    const newSelection = [];
                    blocks.forEach(b => {
                        const v = b.position.clone().project(camera);
                        const x = (v.x * 0.5 + 0.5) * rect.width + rect.left;
                        const y = (-(v.y) * 0.5 + 0.5) * rect.height + rect.top;
                        if(x >= left && x <= left + width && y >= top && y <= top + height) {
                            newSelection.push(b);
                        }
                    });
                    
                    if (e.ctrlKey) {
                        handleSelection([...selectedBlocks, ...newSelection]);
                    } else {
                        handleSelection(newSelection);
                    }
                }
            }
        }

        // --- Shape Editor ---
        window.toggleShapeEdit = () => {
            if (selectedBlocks.length !== 1) {
                alert("请选择一个体块进行编辑");
                return;
            }
            isShapeEditMode = !isShapeEditMode;
            const btn = document.getElementById('btn-edit-shape');
            if (isShapeEditMode) {
                btn.classList.add('bg-green-500', 'text-white');
                createShapeHandles(selectedBlocks[0]);
            } else {
                btn.classList.remove('bg-green-500', 'text-white');
                clearShapeHandles();
            }
        };

        function createShapeHandles(block) {
            clearShapeHandles();
            const points = block.userData.points;
            
            // 1. Vertex Handles (White)
            points.forEach((pt, i) => {
                const geo = new THREE.SphereGeometry(1, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const handle = new THREE.Mesh(geo, mat);
                const worldPos = new THREE.Vector3(pt.x, 0, pt.y).applyEuler(block.rotation).add(block.position);
                worldPos.y = block.position.y + block.userData.h/2 + 0.5;
                handle.position.copy(worldPos);
                handle.userData = { isHandle: true, index: i, parentBlock: block };
                scene.add(handle);
                shapeHandles.push(handle);
            });

            // 2. Midpoint Ghost Handles (Gray, for adding points)
            for (let i = 0; i < points.length; i++) {
                const nextI = (i + 1) % points.length;
                const pt = points[i];
                const nextPt = points[nextI];
                const midX = (pt.x + nextPt.x) / 2;
                const midY = (pt.y + nextPt.y) / 2;

                const geo = new THREE.SphereGeometry(0.6, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.8 });
                const ghost = new THREE.Mesh(geo, mat);

                const worldPos = new THREE.Vector3(midX, 0, midY).applyEuler(block.rotation).add(block.position);
                worldPos.y = block.position.y + block.userData.h/2 + 0.5;

                ghost.position.copy(worldPos);
                ghost.userData = { isHandle: true, isGhost: true, index: i, parentBlock: block };
                scene.add(ghost);
                shapeHandles.push(ghost);
            }
        }

        function updateShapeHandles() {
            if (selectedBlocks.length !== 1) {
                if(isShapeEditMode) window.toggleShapeEdit(); 
                return;
            }
            const block = selectedBlocks[0];
            // Since point count might change, just recreate
            createShapeHandles(block);
        }

        function clearShapeHandles() {
            shapeHandles.forEach(h => scene.remove(h));
            shapeHandles = [];
        }

        // --- Export Data (Restored & Updated) ---
        window.exportData = () => {
            const data = {
                version: "4.0",
                timestamp: new Date().toISOString(),
                blocks: blocks.map(b => ({
                    id: b.userData.id,
                    name: b.userData.name,
                    cat: b.userData.cat,
                    color: b.userData.color,
                    beds: b.userData.beds,
                    pos: { x: b.position.x, y: b.position.y, z: b.position.z },
                    // w/d are kept for reference, but points define shape
                    scale: { w: b.userData.w, h: b.userData.h, d: b.userData.d }, 
                    points: b.userData.points,
                    subNodes: b.userData.subNodes,
                    syntax: b.userData.syntax
                })),
                l1Matrix: matrix,
                l2Matrix: l2Matrix,
                metrics: windowAnalysisData
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type : 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `hospital_plan_v4.0_syntax_${Date.now()}.json`;
            a.click();
        };

        // --- Report Generation (Restored) ---
        function generateReport() {
            const catAreas = { 'public': totalPublicArea };
            let totalArea = totalPublicArea;
            let totalBeds = 0;

            blocks.forEach(b => {
                // Approximate area for custom shapes using simple polygon area
                // Or just box for fallback
                let area = 0;
                if (b.userData.points) {
                    // Shoelace formula
                    const pts = b.userData.points;
                    let areaSum = 0;
                    for (let i = 0; i < pts.length; i++) {
                        const j = (i + 1) % pts.length;
                        areaSum += pts[i].x * pts[j].y;
                        areaSum -= pts[i].y * pts[j].x;
                    }
                    area = Math.abs(areaSum) / 2;
                } else {
                    area = b.userData.w * b.userData.d;
                }
                
                const cat = b.userData.cat || 'admin';
                if(!catAreas[cat]) catAreas[cat] = 0;
                catAreas[cat] += area;
                totalArea += area;
                totalBeds += (b.userData.beds || 0);
            });

            // 1. Render Charts
            const ctxArea = document.getElementById('areaChart').getContext('2d');
            const ctxFlow = document.getElementById('flowChart').getContext('2d');
            
            if(areaChart) areaChart.destroy();
            if(flowChart) flowChart.destroy();

            const style = getComputedStyle(document.body);
            const textColor = style.getPropertyValue('--chart-text').trim();
            const gridColor = style.getPropertyValue('--chart-grid').trim();

            const labels = [], data = [], colors = [];
            Object.keys(gbBenchmarks).forEach(k => {
                if(catAreas[k] > 0) {
                    labels.push(gbBenchmarks[k].label);
                    data.push(catAreas[k]);
                    colors.push(gbBenchmarks[k].color);
                }
            });

            areaChart = new Chart(ctxArea, {
                type: 'doughnut',
                data: { labels, datasets: [{ data, backgroundColor: colors, borderWidth: 0 }] },
                options: { responsive: true, plugins: { legend: { position: 'right', labels: { color: textColor } } } }
            });

            const deptLabels = blocks.map(b => b.userData.name);
            const deptFlow = blocks.map(b => {
                let load = 0;
                connections.forEach(c => { if(c.b1===b || c.b2===b) load += c.strength * c.distTotal; });
                return load;
            });

            flowChart = new Chart(ctxFlow, {
                type: 'bar',
                data: { labels: deptLabels, datasets: [{ label: '流程负荷', data: deptFlow, backgroundColor: '#3b82f6', borderRadius: 4 }] },
                options: { responsive: true, scales: { y: { grid: {color:gridColor}, ticks:{color:textColor} }, x: { ticks:{color:textColor}, grid: {display:false} } }, plugins: { legend: { display: false } } }
            });

            // 2. Compliance Table
            const compBody = document.getElementById('compliance-table-body');
            compBody.innerHTML = '';
            Object.keys(gbBenchmarks).forEach(k => {
                const b = gbBenchmarks[k];
                const area = catAreas[k] || 0;
                const ratio = totalArea > 0 ? (area/totalArea*100) : 0;
                let status = '合理', cls = 'status-ok';
                if(ratio < b.min) { status='偏低'; cls='status-warn'; }
                if(ratio > b.max) { status='偏高'; cls='status-warn'; }
                
                compBody.innerHTML += `
                    <tr class="report-cell">
                        <td class="font-bold" style="color:${b.color}">${b.label}</td>
                        <td class="font-mono">${area.toFixed(0)}</td>
                        <td class="font-mono">${ratio.toFixed(1)}%</td>
                        <td class="text-xs" style="color:var(--text-muted)">${b.min}%-${b.max}%</td>
                        <td><span class="status-badge ${cls}">${status}</span></td>
                    </tr>
                `;
            });

            // 3. KPI Table
            const kpiBody = document.getElementById('report-table-body');
            const metrics = windowAnalysisData;
            
            // Find most integrated and most choice
            let maxIntName = "-", maxChoiceName = "-";
            let maxIntVal = 0, maxChoiceVal = 0;
            blocks.forEach(b => {
                if(b.userData.syntax.integration > maxIntVal) { maxIntVal = b.userData.syntax.integration; maxIntName = b.userData.name; }
                if(b.userData.syntax.choice > maxChoiceVal) { maxChoiceVal = b.userData.syntax.choice; maxChoiceName = b.userData.name; }
            });

            kpiBody.innerHTML = `
                <tr class="report-cell"><td class="py-2 text-blue-400 font-bold">总建筑面积</td><td class="font-mono text-white">${totalArea.toFixed(0)} m²</td><td class="text-xs text-gray-500">-</td><td>-</td></tr>
                <tr class="report-cell"><td class="py-2 text-blue-400 font-bold">总床位数</td><td class="font-mono text-white">${totalBeds}</td><td class="text-xs text-gray-500">-</td><td>-</td></tr>
                <tr class="report-cell"><td class="py-2">单床建筑面积</td><td class="font-mono text-white">${totalBeds>0 ? (totalArea/totalBeds).toFixed(1) : 0} m²/bed</td><td class="text-xs text-gray-500">60-90</td><td>${totalBeds>0 ? ((totalArea/totalBeds)>60?'OK':'Low') : '-'}</td></tr>
                <tr class="report-cell"><td class="py-2">流程阻力 (FRI)</td><td class="font-mono text-white">${metrics.fri}</td><td class="text-xs text-gray-500"><1.0</td><td>${metrics.fri<1.0?'<span class="status-badge status-ok">优</span>':'<span class="status-badge status-bad">需优化</span>'}</td></tr>
                <tr class="report-cell"><td class="py-2">垂直效能 (VEC)</td><td class="font-mono text-white">${metrics.vhRatio}</td><td class="text-xs text-gray-500"><1.4</td><td>${metrics.vhRatio<1.4?'<span class="status-badge status-ok">优</span>':'<span class="status-badge status-warn">一般</span>'}</td></tr>
                <tr class="report-cell"><td class="py-2 text-purple-400 font-bold">最高集成度节点</td><td class="font-mono text-white">${maxIntName}</td><td class="text-xs text-gray-500">核心位置</td><td>Integration: ${maxIntVal.toFixed(2)}</td></tr>
                <tr class="report-cell"><td class="py-2 text-purple-400 font-bold">最高穿行度节点</td><td class="font-mono text-white">${maxChoiceName}</td><td class="text-xs text-gray-500">交通枢纽</td><td>Choice: ${maxChoiceVal}</td></tr>
            `;
        }

        // --- Generative Design (Restored) ---
        window.startGenerativeDesign = () => {
            if(generativeDesignRunning) {
                generativeDesignRunning = false;
                document.querySelector('button[onclick="startGenerativeDesign()"]').innerHTML = '<i class="fas fa-dice"></i> 生成式设计';
                return; 
            }
            if(blocks.length === 0) return alert("请先添加科室");

            generativeDesignRunning = true;
            currentIteration = 0;
            candidateSolutions = [];
            bestSolutions = [];
            document.querySelector('button[onclick="startGenerativeDesign()"]').textContent = '停止生成';
            
            showGenerativePanel();
            runGenerativeIteration();
        };

        function showGenerativePanel() {
            let panel = document.getElementById('gen-panel');
            if(!panel) {
                panel = document.createElement('div');
                panel.id = 'gen-panel';
                panel.className = 'panel';
                panel.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:400px; padding:20px; z-index:3000;';
                panel.innerHTML = `
                    <h3 class="text-lg font-bold mb-2">正在优化布局...</h3>
                    <div class="text-sm mb-1">迭代: <span id="gen-iter">0</span> / ${maxIterations}</div>
                    <div class="w-full bg-gray-700 h-2 rounded mb-4"><div id="gen-bar" class="bg-blue-500 h-2 rounded" style="width:0%"></div></div>
                    <div id="gen-best" class="text-xs text-green-400 mb-4">最佳分数: 0</div>
                    <button class="btn btn-secondary w-full" onclick="window.startGenerativeDesign()">停止并应用最佳</button>
                `;
                document.body.appendChild(panel);
            }
            panel.style.display = 'block';
        }

        function runGenerativeIteration() {
            if(!generativeDesignRunning || currentIteration >= maxIterations) {
                finishGenerativeDesign();
                return;
            }
            currentIteration++;
            
            let newLayout = blocks.map(b => ({ id: b.userData.id, pos: b.position.clone() }));
            
            const idx = Math.floor(Math.random() * newLayout.length);
            const target = newLayout[idx];
            
            // Fixed Logic in Generative Design
            const realBlock = blocks.find(b => b.userData.id === target.id);
            if (!realBlock || realBlock.userData.fixed) {
                return setTimeout(runGenerativeIteration, 0); 
            }

            target.pos.x += (Math.random()-0.5) * 20;
            target.pos.z += (Math.random()-0.5) * 20;
            
            let score = 0;
            let distPenalty = 0;
            
            for(let i=0; i<newLayout.length; i++) {
                for(let j=i+1; j<newLayout.length; j++) {
                    const b1 = newLayout[i];
                    const b2 = newLayout[j];
                    const str = getRelation(b1.id, b2.id);
                    if(str > 0) {
                        const d = b1.pos.distanceTo(b2.pos);
                        distPenalty += d * str;
                    }
                }
            }
            score = 10000 - distPenalty;

            bestSolutions.push({ layout: newLayout, score: score });
            bestSolutions.sort((a,b) => b.score - a.score);
            if(bestSolutions.length > 5) bestSolutions.pop();

            document.getElementById('gen-iter').innerText = currentIteration;
            document.getElementById('gen-bar').style.width = (currentIteration/maxIterations*100) + '%';
            document.getElementById('gen-best').innerText = '最佳分数: ' + bestSolutions[0].score.toFixed(0);

            setTimeout(runGenerativeIteration, 10);
        }

        function finishGenerativeDesign() {
            generativeDesignRunning = false;
            document.querySelector('button[onclick="startGenerativeDesign()"]').innerHTML = '<i class="fas fa-dice"></i> 生成式设计';
            document.getElementById('gen-panel').style.display = 'none';
            
            if(bestSolutions.length > 0) {
                const best = bestSolutions[0];
                best.layout.forEach(item => {
                    const block = blocks.find(b => b.userData.id === item.id);
                    if(block && !block.userData.fixed) block.position.copy(item.pos);
                });
                updateSystem();
                alert("已应用最佳生成布局");
            }
        }

        // --- Common Helpers ---
        window.switchMatrixLevel = (level) => {
            matrixLevel = level;
            document.getElementById('tab-l1').classList.toggle('active', level === 'l1');
            document.getElementById('tab-l2').classList.toggle('active', level === 'l2');
            document.getElementById('matrix-hint').textContent = level === 'l1' 
                ? '设置科室间吸引力 (0-5)' 
                : '设置具体功能点之间的微观连接 (0-5)';
            renderMatrix();
        };

        function renderMatrix() {
            const el = document.getElementById('matrix-editor');
            el.innerHTML = '';
            
            let items = [];
            let getRelFn, setRelFn;

            if (matrixLevel === 'l1') {
                items = blocks;
                getRelFn = (a,b) => getRelation(a.userData.id, b.userData.id);
                setRelFn = (a,b,v) => setRelation(a.userData.id, b.userData.id, v);
            } else {
                blocks.forEach(b => {
                    b.userData.subNodes.forEach(sn => {
                        items.push({ 
                            userData: { 
                                id: sn.id, 
                                name: sn.name || sn.id.replace(b.userData.id+'_', ''), 
                                parentName: b.userData.name
                            } 
                        });
                    });
                });
                getRelFn = (a,b) => getL2Relation(a.userData.id, b.userData.id);
                setRelFn = (a,b,v) => setL2Relation(a.userData.id, b.userData.id, v);
            }

            const count = items.length;
            if (count === 0) {
                el.innerHTML = '<div class="text-xs text-center w-full py-4 opacity-50">暂无数据</div>';
                return;
            }

            const cellSize = 24;
            const labelColWidth = 80;
            el.style.gridTemplateColumns = `${labelColWidth}px repeat(${count}, ${cellSize}px)`;
            
            items.forEach((b1, i) => {
                const label = document.createElement('div');
                label.className = 'matrix-row-label';
                label.innerText = b1.userData.name;
                if(matrixLevel === 'l2') label.title = b1.userData.parentName + ' > ' + b1.userData.name;
                el.appendChild(label);

                items.forEach((b2, j) => {
                    const cell = document.createElement('div');
                    if(i === j) {
                        cell.className = 'matrix-cell-diagonal';
                        cell.innerText = '·';
                    } else if (j > i) {
                        cell.className = 'matrix-cell-hidden';
                    } else {
                        const val = getRelFn(b1, b2);
                        cell.className = `matrix-cell val-${val}`;
                        cell.innerText = val > 0 ? val : '';
                        cell.onclick = () => {
                            const n = (val + 1) % 6;
                            setRelFn(b1, b2, n);
                            renderMatrix();
                            updateSystem();
                        };
                    }
                    el.appendChild(cell);
                });
            });

            el.appendChild(document.createElement('div'));
            items.forEach(b => {
                const d = document.createElement('div');
                d.className = 'matrix-header';
                d.innerText = b.userData.name.substring(0,6);
                el.appendChild(d);
            });
        }

        window.addL2Unit = () => {
            if(selectedBlocks.length !== 1) return;
            const b = selectedBlocks[0];
            const count = b.userData.subNodes.length + 1;
            const newId = `${b.userData.id}_u${count}`;
            const rx = (Math.random()-0.5) * (b.userData.w * 0.8);
            const rz = (Math.random()-0.5) * (b.userData.d * 0.8);
            // Default Name and Type
            b.userData.subNodes.push({ 
                id: newId, 
                name: `功能点_${count}`,
                type: '设备',
                x: rx, y: 0, z: rz 
            });
            updateSystem();
            fillPropertyPanel(b);
            if (matrixLevel === 'l2') renderMatrix();
        };

        window.deleteL2Unit = (idx) => {
            if(selectedBlocks.length !== 1) return;
            const b = selectedBlocks[0];
            const sn = b.userData.subNodes[idx];
            Object.keys(l2Matrix).forEach(k => { if(k.includes(sn.id)) delete l2Matrix[k]; });
            b.userData.subNodes.splice(idx, 1);
            updateSystem();
            fillPropertyPanel(b);
            if (matrixLevel === 'l2') renderMatrix();
        };

        window.updateSubNodeName = (idx, val) => {
            if(selectedBlocks.length !== 1) return;
            selectedBlocks[0].userData.subNodes[idx].name = val;
            if (matrixLevel === 'l2') renderMatrix();
        };

        window.updateSubNodeType = (idx, val) => {
            if(selectedBlocks.length !== 1) return;
            selectedBlocks[0].userData.subNodes[idx].type = val;
        };

        function updateL2Visuals() {
            l2Meshes.forEach(m => scene.remove(m));
            l2Lines.forEach(l => scene.remove(l));
            l2Meshes = []; l2Lines = [];
            const worldPositions = {};

            blocks.forEach(b => {
                b.userData.subNodes.forEach(sn => {
                    const geo = new THREE.BoxGeometry(2, 2, 2); 
                    const mat = new THREE.MeshBasicMaterial({ color: 0xf97316, depthTest: false });
                    const mesh = new THREE.Mesh(geo, mat);
                    const worldPos = new THREE.Vector3(sn.x, sn.y, sn.z).applyEuler(b.rotation).add(b.position);
                    mesh.position.copy(worldPos);
                    mesh.renderOrder = 999;
                    scene.add(mesh);
                    l2Meshes.push(mesh);
                    worldPositions[sn.id] = worldPos;
                });
            });

            Object.keys(l2Matrix).forEach(key => {
                const strength = l2Matrix[key];
                if(strength <= 0) return;
                const [id1, id2] = key.split('-');
                const p1 = worldPositions[id1];
                const p2 = worldPositions[id2];
                if(p1 && p2) {
                    const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                    const mat = new THREE.LineBasicMaterial({ color: 0xf97316, transparent: true, opacity: 0.8, linewidth: 2 });
                    const line = new THREE.Line(geo, mat);
                    scene.add(line);
                    l2Lines.push(line);
                }
            });
        }

        function fillPropertyPanel(mesh) {
            document.getElementById('selection-panel').style.display = 'block';
            document.getElementById('no-selection').style.display = 'none';
            document.getElementById('multi-selection-panel').style.display = 'none';
            const d = mesh.userData;
            document.getElementById('prop-name').value = d.name;
            document.getElementById('prop-color').value = d.color;
            document.getElementById('prop-beds').value = d.beds || 0;
            document.getElementById('prop-w').value = d.w;
            document.getElementById('prop-h').value = d.h;
            document.getElementById('prop-d').value = d.d;
            document.getElementById('prop-y').value = mesh.position.y;
            document.getElementById('prop-fixed').checked = !!d.fixed;
            
            fillSyntaxPanel(mesh); // Fill syntax stats

            let area = 0;
            if (d.points) {
                let areaSum = 0;
                for (let i = 0; i < d.points.length; i++) {
                    const j = (i + 1) % d.points.length;
                    areaSum += d.points[i].x * d.points[j].y;
                    areaSum -= d.points[i].y * d.points[j].x;
                }
                area = Math.abs(areaSum) / 2;
            } else {
                area = d.w * d.d;
            }
            document.getElementById('prop-area-input').value = area.toFixed(0);
            
            const l2List = document.getElementById('l2-units-list');
            l2List.innerHTML = '';
            d.subNodes.forEach((sn, idx) => {
                const row = document.createElement('div');
                row.className = 'flex flex-col gap-1 mb-2 p-2 bg-white/5 rounded border border-white/10';
                
                // Header
                const header = document.createElement('div');
                header.className = 'flex justify-between items-center text-[10px] text-gray-400';
                header.innerHTML = `<span>ID: ${sn.id.split('_').pop()}</span> <i class="fas fa-times cursor-pointer hover:text-red-400" onclick="deleteL2Unit(${idx})"></i>`;
                row.appendChild(header);

                // Inputs
                const inputs = document.createElement('div');
                inputs.className = 'flex gap-1';
                
                // Name Input
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'w-1/2 bg-black/20 border border-white/10 rounded px-1 text-[10px] text-white';
                nameInput.value = sn.name || sn.id;
                nameInput.placeholder = '名称';
                nameInput.onchange = (e) => updateSubNodeName(idx, e.target.value);
                
                // Type Select
                const typeSelect = document.createElement('select');
                typeSelect.className = 'w-1/2 bg-black/20 border border-white/10 rounded px-1 text-[10px] text-white';
                const types = ['设备', '人员', '病患', '物资', '洁净', '污物', '其他'];
                types.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.text = t;
                    if(sn.type === t) opt.selected = true;
                    typeSelect.appendChild(opt);
                });
                typeSelect.onchange = (e) => updateSubNodeType(idx, e.target.value);

                inputs.appendChild(nameInput);
                inputs.appendChild(typeSelect);
                row.appendChild(inputs);

                l2List.appendChild(row);
            });
            updatePropStats(mesh);
            
            if(isShapeEditMode) {
                createShapeHandles(mesh);
            }
        }

        function fillSyntaxPanel(mesh) {
            const s = mesh.userData.syntax || { integration: 0, choice: 0, connectivity: 0, control: 0 };
            document.getElementById('syn-int').innerText = s.integration.toFixed(2);
            document.getElementById('syn-ch').innerText = s.choice.toFixed(0);
            document.getElementById('syn-con').innerText = s.connectivity;
            document.getElementById('syn-ctr').innerText = s.control.toFixed(2);
        }

        // ... [Rest of the code remains the same] ...
        // (animate, setPhysicsMode, applyPhysics, updateBlockGeometry, etc.)
        
        window.setPhysicsMode = (mode) => {
            physicsMode = mode;
            [0,1,2].forEach(m => document.getElementById(`btn-phy-${m}`).classList.toggle('active', m === mode));
        };

        function applyPhysics() {
            if(physicsMode === 0 || isDragging) return;

            blocks.forEach(b1 => {
                if (b1.userData.fixed) return; // Skip updating position if fixed
                
                let force = new THREE.Vector3(0,0,0);
                if(b1.position.length() > 200) force.add(b1.position.clone().negate().multiplyScalar(0.01));
                blocks.forEach(b2 => {
                    if(b1 === b2) return;
                    const dist = b1.position.distanceTo(b2.position);
                    const minDist = (Math.max(b1.userData.w, b1.userData.d) + Math.max(b2.userData.w, b2.userData.d)) / 1.8;
                    const dy = Math.abs(b1.position.y - b2.position.y);
                    if(dist < minDist && dy < (b1.userData.h+b2.userData.h)/2) {
                        const diff = new THREE.Vector3().subVectors(b1.position, b2.position);
                        force.add(diff.normalize().multiplyScalar((minDist - dist) * 0.2));
                    }
                });
                b1.position.add(force);
            });

            if (physicsMode === 1) {
                connections.forEach(c => {
                   if (c.strength > 0) {
                       const diff = new THREE.Vector3().subVectors(c.b2.position, c.b1.position);
                       const dist = diff.length();
                       const target = 50 - (c.strength * 5);
                       if (dist > target) {
                           const pull = diff.normalize().multiplyScalar((dist - target) * 0.005 * c.strength);
                           if (!c.b1.userData.fixed) c.b1.position.add(pull);
                           if (!c.b2.userData.fixed) c.b2.position.sub(pull);
                       }
                   } 
                });
            }

            if (physicsMode === 2) {
                const l2World = {};
                blocks.forEach(b => {
                    b.userData.subNodes.forEach(sn => {
                        const wp = new THREE.Vector3(sn.x, sn.y, sn.z).add(b.position);
                        l2World[sn.id] = { pos: wp, parent: b, local: sn };
                    });
                });
                Object.keys(l2Matrix).forEach(k => {
                    const str = l2Matrix[k];
                    if (str <= 0) return;
                    const [id1, id2] = k.split('-');
                    const n1 = l2World[id1];
                    const n2 = l2World[id2];
                    if (n1 && n2) {
                        const diff = new THREE.Vector3().subVectors(n2.pos, n1.pos);
                        const dist = diff.length();
                        const targetDist = 10;
                        if (dist > targetDist) {
                            const forceMag = (dist - targetDist) * 0.01 * str;
                            const force = diff.normalize().multiplyScalar(forceMag);
                            // Constrain logic needs update for custom shape logic if strict
                            // Using simple bbox for now
                            const limitX = n1.parent.userData.w / 2;
                            const limitZ = n1.parent.userData.d / 2;
                            n1.local.x = THREE.MathUtils.clamp(n1.local.x + force.x, -limitX, limitX);
                            n1.local.z = THREE.MathUtils.clamp(n1.local.z + force.z, -limitZ, limitZ);
                            n2.local.x = THREE.MathUtils.clamp(n2.local.x - force.x, -n2.parent.userData.w/2, n2.parent.userData.w/2);
                            n2.local.z = THREE.MathUtils.clamp(n2.local.z - force.z, -n2.parent.userData.d/2, n2.parent.userData.d/2);
                            
                            const parentDragFactor = 0.2; 
                            if (!n1.parent.userData.fixed) n1.parent.position.add(force.multiplyScalar(parentDragFactor));
                            if (!n2.parent.userData.fixed) n2.parent.position.sub(force.multiplyScalar(parentDragFactor));
                        }
                    }
                });
            }
            updateConnections();
        }

        window.toggleLabels = () => {
            showDistanceLabels = !showDistanceLabels;
            document.getElementById('btn-labels').classList.toggle('active', showDistanceLabels);
            connections.forEach(c => { if (c.label) c.label.style.display = showDistanceLabels ? 'block' : 'none'; });
        };

        window.toggleDaylightMode = () => {
            isDaylightMode = !isDaylightMode;
            // Force disable syntax mode if enabled
            if(syntaxMode !== 'none') { syntaxMode = 'none'; document.getElementById('btn-syntax').classList.remove('active'); }
            
            document.getElementById('btn-daylight').classList.toggle('active');
            if(!isDaylightMode) {
                resetBlockColors();
            } else {
                runDaylightAnalysis();
            }
        };

        window.toggleSyntaxMode = () => {
             // Cycle: None -> Integration -> Choice -> None
             if (syntaxMode === 'none') {
                 syntaxMode = 'integration';
                 isDaylightMode = false; document.getElementById('btn-daylight').classList.remove('active');
             } else if (syntaxMode === 'integration') {
                 syntaxMode = 'choice';
             } else {
                 syntaxMode = 'none';
             }

             const btn = document.getElementById('btn-syntax');
             btn.classList.toggle('active', syntaxMode !== 'none');
             
             // Tooltip update
             btn.title = syntaxMode === 'none' ? '空间句法热力图' : (syntaxMode === 'integration' ? '当前: 集成度 (Integration)' : '当前: 穿行度 (Choice)');
             
             if (syntaxMode === 'none') resetBlockColors();
             else runSyntaxVisuals();
        };

        function resetBlockColors() {
            blocks.forEach(b => {
                b.material.color.set(b.userData.originalColor);
                b.material.emissive.set(0x000000);
            });
        }

        function runDaylightAnalysis() {
            blocks.forEach(b => {
                if(b.userData.isLandlocked) {
                    b.material.color.set(0x333333); b.material.emissive.set(0x000000);
                } else {
                    const h = Math.min(b.position.y / 50, 1);
                    b.material.color.setHSL(0.1 + h*0.1, 0.8, 0.5);
                }
            });
        }

        function runSyntaxVisuals() {
            // Find Min/Max for normalization
            let vals = [];
            blocks.forEach(b => {
                vals.push(syntaxMode === 'integration' ? b.userData.syntax.integration : b.userData.syntax.choice);
            });
            const max = Math.max(...vals) || 1;
            const min = Math.min(...vals) || 0;
            const range = max - min;

            blocks.forEach(b => {
                const val = syntaxMode === 'integration' ? b.userData.syntax.integration : b.userData.syntax.choice;
                // Heatmap: Blue (Low) -> Red (High)
                const norm = range === 0 ? 0.5 : (val - min) / range;
                // Hue: 0.66 (Blue) -> 0.0 (Red)
                const hue = (1.0 - norm) * 0.66;
                b.material.color.setHSL(hue, 1.0, 0.5);
                b.material.emissive.set(0x000000);
            });
        }

        function analyzeMetrics() {
            let totalWeightedDist = 0;
            let blackRooms = 0;
            let totalVol = 0, totalSurf = 0;
            connections.forEach(c => { totalWeightedDist += c.distTotal * c.strength; });
            const fri = connections.length ? (totalWeightedDist / (connections.length * 50)) : 0;
            blocks.forEach(b => {
                const w = b.userData.w, h = b.userData.h, d = b.userData.d;
                totalVol += w*h*d;
                totalSurf += 2*(w*h+h*d+w*d);
                let covered = 0;
                blocks.forEach(o => {
                   if(b===o) return;
                   const dx = Math.abs(b.position.x - o.position.x);
                   const dz = Math.abs(b.position.z - o.position.z);
                   if (dx < (b.userData.w+o.userData.w)/2 && dz < (b.userData.d+o.userData.d)/2) covered++;
                });
                b.userData.isLandlocked = covered >= 3;
                if(b.userData.isLandlocked) blackRooms++;
            });
            const compactness = totalVol > 0 ? (totalSurf/totalVol) : 0;
            
            const metrics = { fri: fri.toFixed(2), vhRatio: (fri*0.4).toFixed(2), blackRooms, compactness: compactness.toFixed(2) };
            windowAnalysisData = metrics;

            updateKPI('kpi-flow', metrics.fri, fri > 1.5 ? 'bad' : 'good');
            updateKPI('kpi-vh', metrics.vhRatio, 'good');
            updateKPI('kpi-light', blackRooms, blackRooms > 0 ? 'bad' : 'good');
        }

        function updateKPI(id, val, status) {
            const el = document.getElementById(id);
            el.querySelector('.kpi-value').innerText = val;
            el.className = `kpi-card ${status}`;
        }

        function handleSelection(selection) {
            selectedBlocks = selection;
            transformControl.detach();
            
            // Exit shape mode if deselecting
            if(isShapeEditMode && (selection.length !== 1 || selection[0] !== shapeHandles[0]?.userData.parentBlock)) {
                window.toggleShapeEdit();
            }

            if(selectedBlocks.length === 1) {
                fillPropertyPanel(selectedBlocks[0]);
                transformControl.attach(selectedBlocks[0]); // Attach Gumball
            } else if (selectedBlocks.length > 1) {
                document.getElementById('selection-panel').style.display = 'none';
                document.getElementById('no-selection').style.display = 'none';
                document.getElementById('multi-selection-panel').style.display = 'block';
                document.getElementById('multi-count').innerText = selectedBlocks.length;
            } else {
                document.getElementById('selection-panel').style.display = 'none';
                document.getElementById('multi-selection-panel').style.display = 'none';
                document.getElementById('no-selection').style.display = 'block';
            }
        }
        
        window.deleteSelection = () => {
             if(selectedBlocks.length === 0) return;
             saveState();
             transformControl.detach();
             selectedBlocks.forEach(b => {
                 scene.remove(b);
                 if(b.userData.labelEl) b.userData.labelEl.remove();
                 blocks = blocks.filter(x => x !== b);
                 Object.keys(matrix).forEach(k => { if(k.includes(b.userData.id)) delete matrix[k]; });
                 b.userData.subNodes.forEach(sn => {
                    Object.keys(l2Matrix).forEach(k => { if(k.includes(sn.id)) delete l2Matrix[k]; });
                 });
             });
             selectedBlocks = [];
             handleSelection([]);
             updateSystem();
             renderMatrix();
        };

        function updatePropStats(mesh) {
            const areaInput = document.getElementById('prop-area-input');
            if(areaInput.value) {
                const area = parseFloat(areaInput.value);
                document.getElementById('prop-area').innerText = area.toFixed(0);
                document.getElementById('prop-vol').innerText = (area * mesh.userData.h).toFixed(0);
            }
        }

        ['prop-name','prop-beds'].forEach(id => {
            document.getElementById(id).addEventListener('input', e => {
                if(selectedBlocks.length !== 1) return;
                selectedBlocks[0].userData[id.replace('prop-','')] = e.target.value;
                updateLabels();
            });
        });
        
        // Handle W/H/D inputs - now they scale points
        ['prop-w','prop-d'].forEach(id => {
            document.getElementById(id).addEventListener('input', e => {
                if(selectedBlocks.length !== 1) return;
                const b = selectedBlocks[0];
                const dim = id.replace('prop-',''); // w or d
                const val = parseFloat(e.target.value) || 1;
                
                // Scale factor logic
                const oldVal = b.userData[dim];
                const ratio = val / oldVal;
                
                // Update Points
                b.userData.points.forEach(p => {
                    if (dim === 'w') p.x *= ratio;
                    if (dim === 'd') p.y *= ratio;
                });
                
                b.userData[dim] = val;
                
                updateBlockGeometry(b);
                updateSystem();
                fillPropertyPanel(b); // Update area calc
            });
        });
        
        document.getElementById('prop-h').addEventListener('input', e => {
            if(selectedBlocks.length !== 1) return;
            selectedBlocks[0].userData.h = parseFloat(e.target.value) || 1;
            updateBlockGeometry(selectedBlocks[0]);
            updateSystem();
            updatePropStats(selectedBlocks[0]);
        });

        document.getElementById('prop-color').addEventListener('input', e => {
            if(selectedBlocks.length !== 1) return;
            selectedBlocks[0].userData.color = e.target.value;
            selectedBlocks[0].material.color.set(e.target.value);
            updateLabels();
        });

        document.getElementById('prop-fixed').addEventListener('change', e => {
            if(selectedBlocks.length !== 1) return;
            selectedBlocks[0].userData.fixed = e.target.checked;
        });
        
        function updateLabels() {
            const layer = document.getElementById('labels-layer');
            const old = layer.querySelectorAll('.dept-label');
            old.forEach(o => o.remove());
            blocks.forEach(b => {
                const el = document.createElement('div');
                el.className = 'dept-label';
                // Estimate area for label
                let area = b.userData.w * b.userData.d; 
                if (b.userData.points) {
                     // Recalc area for display
                     let s = 0;
                     const p = b.userData.points;
                     for(let i=0;i<p.length;i++) { s += p[i].x*p[(i+1)%p.length].y - p[i].y*p[(i+1)%p.length].x; }
                     area = Math.abs(s)/2;
                }
                
                el.innerHTML = `<div class="dept-name" style="border-left:3px solid ${b.userData.color}">${b.userData.name}<span class="dept-area">${area.toFixed(0)}m²</span></div>`;
                if(b.userData.isLandlocked) el.innerHTML += `<div class="dept-issue">采光差</div>`;
                b.userData.labelEl = el;
                layer.appendChild(el);
            });
            document.getElementById('dept-list').innerHTML = blocks.map(b => 
                `<div class="flex justify-between items-center text-xs p-2 rounded cursor-pointer hover:bg-opacity-10 bg-white bg-opacity-5" onclick="window.focusBlock('${b.userData.id}')">
                    <span class="flex items-center gap-2"><div style="width:8px;height:8px;border-radius:50%;background:${b.userData.color}"></div>${b.userData.name}</span>
                    <span class="opacity-50">${b.userData.subNodes.length} pts</span>
                 </div>`
            ).join('');
        }

        window.focusBlock = (id) => {
            const b = blocks.find(x => x.userData.id === id);
            if(b) handleSelection([b]);
        };

        window.updateSliceHeight = (v) => { 
            sliceY = parseFloat(v); 
            document.getElementById('slice-display').textContent = isSliceMode ? `Layer ${Math.floor(sliceY/4)+1}` : "ALL"; 
            updateSliceView(); 
        };
        window.toggleSliceMode = () => { isSliceMode = !isSliceMode; updateSliceView(); };
        function updateSliceView() {
            blocks.forEach(m => {
                if(!isSliceMode) { 
                    // Reset opacity based on whether we are in syntax mode or normal mode
                    // If syntax mode, we need full opacity to see color
                    m.material.opacity = 0.9; 
                    return; 
                }
                const b = m.position.y - m.userData.h/2;
                const t = m.position.y + m.userData.h/2;
                m.material.opacity = (sliceY >= b && sliceY <= t) ? 0.9 : 0.1;
            });
        }
        
        window.setView = (mode) => {
            const size = 300;
            const end = new THREE.Vector3();
            if(mode === 'top') end.set(0, size, 0);
            if(mode === 'south') end.set(0, 0, size);
            if(mode === 'north') end.set(0, 0, -size);
            if(mode === 'east') end.set(size, 0, 0);
            if(mode === 'west') end.set(-size, 0, 0);
            camera.position.copy(end);
            camera.lookAt(0,0,0);
            camera.updateProjectionMatrix();
        };
        window.resetView = () => {
            camera.position.set(200, 200, 200);
            camera.lookAt(0,0,0);
            camera.zoom = 1;
            camera.updateProjectionMatrix();
        };
        window.zoomIn = () => { camera.zoom = Math.min(camera.zoom + 0.1, 5); camera.updateProjectionMatrix(); };
        window.zoomOut = () => { camera.zoom = Math.max(camera.zoom - 0.1, 0.1); camera.updateProjectionMatrix(); };
        
        function onResize() {
            const w = container.clientWidth;
            const h = container.clientHeight;
            const aspect = w / h;
            const size = 300;
            camera.left = -size * aspect / 2;
            camera.right = size * aspect / 2;
            camera.top = size / 2;
            camera.bottom = -size / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }

        window.toggleSidebar = (side) => {
            document.getElementById(`sidebar-${side}`).classList.toggle(`collapsed-${side}`);
            const icon = document.getElementById(`icon-${side}`);
            icon.style.transform = icon.style.transform === 'rotate(180deg)' ? 'rotate(0deg)' : 'rotate(180deg)';
        };
        window.switchTab = (id) => {
            document.querySelectorAll('.view-section').forEach(e=>e.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(e=>e.classList.remove('active'));
            document.getElementById(`view-${id}`).classList.add('active');
            document.querySelector(`[onclick="switchTab('${id}')"]`).classList.add('active');
            if(id === '3d') onResize();
            if(id === 'report') generateReport();
        };
        function saveState() {
             const state = {
                blocks: blocks.map(b => ({ 
                    userData: JSON.parse(JSON.stringify(b.userData)), // Deep copy points
                    pos: b.position.clone()
                })),
                matrix: { ...matrix },
                l2Matrix: { ...l2Matrix }
             };
             historyStack.push(JSON.stringify(state));
             if(historyStack.length > 20) historyStack.shift();
        }
        window.addNewDept = () => {
             saveState();
             const id = 'new_' + Date.now();
             const b = createBlock({ id, name: '新科室', cat:'admin', color: '#ec4899', w: 20, h: 5, d: 20, x: 0, y: 10, z: 0, beds: 0, subNodes: [] });
             updateSystem();
             renderMatrix();
             handleSelection([b]);
        };
        function updateDiagnostics() {
            const list = document.getElementById('diagnostics-list');
            list.innerHTML = '';
            const addDiag = (msg, level='info') => {
                const div = document.createElement('div');
                div.className = `diag-item ${level}`;
                div.innerHTML = `<i class="fas fa-${level==='warn'?'exclamation-circle':'info-circle'}"></i> <span>${msg}</span>`;
                list.appendChild(div);
            };
            if(blocks.some(b => b.userData.isLandlocked)) addDiag('部分房间采光不足 (黑房间)', 'warn');
            if(Object.values(l2Matrix).some(v => v > 4)) addDiag('检测到高优先级 L2 连接', 'info');
            
            // Syntax Diagnostics
            const highChoice = blocks.find(b => b.userData.syntax.choice > 5 && (b.userData.name.includes('手术') || b.userData.name.includes('ICU')));
            if(highChoice) addDiag(`${highChoice.userData.name} 穿行度过高，可能干扰洁净区`, 'warn');
            
            const lowInt = blocks.find(b => b.userData.syntax.integration < 1.0 && (b.userData.name.includes('门诊') || b.userData.name.includes('急诊')));
            if(lowInt) addDiag(`${lowInt.userData.name} 集成度低，患者到达不便`, 'warn');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            applyPhysics();
            
            if(blocks.length > 0) {
                const rect = container.getBoundingClientRect();
                
                blocks.forEach(b => {
                    if (b.userData.labelEl) {
                        const tempV = b.position.clone();
                        tempV.y += b.userData.h / 2 + 2; 
                        tempV.project(camera);
                        
                        if(tempV.z > 1 || Math.abs(tempV.x)>1 || Math.abs(tempV.y)>1) {
                            b.userData.labelEl.style.display = 'none';
                        } else {
                            b.userData.labelEl.style.display = 'flex';
                            const x = (tempV.x * .5 + .5) * rect.width;
                            const y = (-tempV.y * .5 + .5) * rect.height;
                            b.userData.labelEl.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                        }
                    }
                });

                connections.forEach(c => {
                    if (c.label) {
                        const tempV = c.mid.clone().project(camera);
                        if(tempV.z > 1 || Math.abs(tempV.x)>1 || Math.abs(tempV.y)>1) {
                            c.label.style.display = 'none';
                        } else {
                            c.label.style.display = showDistanceLabels ? 'block' : 'none';
                            const x = (tempV.x * .5 + .5) * rect.width;
                            const y = (-tempV.y * .5 + .5) * rect.height;
                            c.label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                        }
                    }
                });
            }

            renderer.render(scene, camera);
        }

        window.openAIModal = () => document.getElementById('ai-modal').style.display = 'flex';
        window.closeAIModal = () => document.getElementById('ai-modal').style.display = 'none';

        init();
    </script>
</body>
</html>
